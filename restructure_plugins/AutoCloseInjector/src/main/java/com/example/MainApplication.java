package com.example;

import com.github.javaparser.StaticJavaParser;
import com.github.javaparser.ast.CompilationUnit;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;

/**
 * Main application that automatically injects 'close' methods for resource
 * fields that are not properly closed in a given class,
 * and adds the 'AutoCloseable' interface to the class if necessary.
 * 
 * This application analyzes warning messages generated by the Checker Framework
 * to identify resource fields that need to be
 * closed. It then injects the appropriate 'close' methods and updates the class
 * to implement 'AutoCloseable' if it doesn't
 * already.
 * 
 * The application operates as follows:
 * 1. Reads the warning messages generated by the Checker Framework, identifying
 * fields that require closing.
 * 2. Modifies the source code of the class to add a 'close' method that
 * properly closes these fields.
 * 3. Ensures the class implements the 'AutoCloseable' interface, if it does not
 * already.
 * 4. Generates a patch file reflecting these changes for each warning message.
 * 
 * This tool requires two command-line arguments:
 * 1. The path to the warning file generated by the Checker Framework.
 * 2. The path to the project directory containing the source code to be
 * modified.
 */
public class MainApplication {

    private static final String PATCH_FILE_NAME = "java-parser-AutoCloseInjector.patch";

    public static void main(String[] args) {
        if (args.length < 2) {
            System.err.println("Usage: java -jar AutoCloseInjector-1.0-SNAPSHOT.jar <warning_file> <project_path>");
            System.exit(1);
        }

        String warningFilePath = args[0];
        String projectPath = args[1];

        // The file patch to store all patches
        String patchFilePath = Paths.get(projectPath, "src", PATCH_FILE_NAME).toString();

        try {
            List<String> warningMessages = Files.readAllLines(Paths.get(warningFilePath));

            // Step 1: Parse Checker Framework Warnings
            WarningParser warningParser = new WarningParser();
            List<WarningParser.Warning> warnings = warningParser.parseWarnings(warningMessages);

            Map<String, Set<String>> classToFieldsMap = new HashMap<>();

            for (WarningParser.Warning warning : warnings) {
                // Step 2: Verify Warning Context and Process Each Warning
                String resolvedFilePath = warning.filePath;
                try (FileInputStream in = new FileInputStream(resolvedFilePath)) {
                    CompilationUnit cu = StaticJavaParser.parse(in);

                    // Get the field initialization information by line number from the compilation
                    // unit
                    Optional<WarningVerifier.FieldInitializationInfo> fieldInfoOpt = WarningVerifier
                            .getFieldInitializationInfo(
                                    cu, warning.lineNumber);
                    if (fieldInfoOpt.isPresent()) {
                        String fieldName = fieldInfoOpt.get().getFieldName();
                        String className = fieldInfoOpt.get().getClassName();
                        classToFieldsMap.computeIfAbsent(resolvedFilePath + "#" + className, k -> new HashSet<>())
                                .add(fieldName + "#" + warning.methodName);
                    }
                }

            }

            try (FileWriter patchFileWriter = new FileWriter(patchFilePath)) {
                for (Map.Entry<String, Set<String>> entry : classToFieldsMap.entrySet()) {
                    String key = entry.getKey();
                    String[] parts = key.split("#");
                    String resolvedFilePath = parts[0];
                    String className = parts[1];
                    Set<String> fieldAndMethodNames = entry.getValue();
                    try (FileInputStream in = new FileInputStream(resolvedFilePath)) {
                        CompilationUnit cu = StaticJavaParser.parse(in);

                        // Step 3: Add the close method to the modified file
                        CloseMethodInjector.addCloseMethod(cu, resolvedFilePath, className, fieldAndMethodNames);

                        // Step 4: Generate the patch and append it to the patch file
                        String modifiedFilePath = resolvedFilePath + ".modified";
                        String patch = PatchFileGenerator.generatePatch(resolvedFilePath, modifiedFilePath);
                        // if patch is not empty, write it to the patch file
                        if (!patch.isEmpty()) {
                            patchFileWriter.write(patch);
                            patchFileWriter.write("\n");
                        }

                        // Delete the modified file after generating the patch
                        new File(modifiedFilePath).delete();
                    } catch (IOException e) {
                        System.out.println("Error processing file: " + resolvedFilePath);
                        e.printStackTrace();
                    }
                }
            } catch (IOException e) {
                System.out.println("Error prorcessing file: " + patchFilePath);
                e.printStackTrace();
            }
        } catch (IOException e) {
            System.out.println("Error reading file: " + warningFilePath);
            e.printStackTrace();
        }
    }
}
